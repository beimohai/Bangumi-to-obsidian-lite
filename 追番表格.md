# 总结
```dataviewjs
// DataviewJS：按观看状态与季度统计动画（完整代码）
// 直接把此代码块粘入 Obsidian 的 DataviewJS 块中运行。

const ROOT_FOLDER = "11. アニメ/追番记录/";

// --- 注入样式：确保第2/3/4列不换行，第一列最多2行显示 ---
dv.paragraph(`<style>
.dataview.table-view-table { table-layout: fixed !important; width: 100% !important; border-collapse: collapse !important; font-size: 13px; }
.dataview.table-view-table th, .dataview.table-view-table td { padding: 4px 6px !important; line-height: 1 !important; vertical-align: middle !important; }

/* 表体：第2/3/4列强制不换行（显示省略），禁止 CJK 中间断行 */
.dataview.table-view-table td:nth-child(2),
.dataview.table-view-table td:nth-child(3),
.dataview.table-view-table td:nth-child(4) {
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  overflow-wrap: normal !important;
  word-break: keep-all !important;
  -webkit-hyphens: none !important;
  hyphens: none !important;
}

/* 表头允许在第2/3/4列按 <br> 换行（便于“个人<br>评分”等显示） */
.dataview.table-view-table thead th:nth-child(2),
.dataview.table-view-table thead th:nth-child(3),
.dataview.table-view-table thead th:nth-child(4) {
  white-space: normal !important;
}

/* 宽度：第2列（季度）较宽，第3/4列窄 */
.dataview.table-view-table th:nth-child(2), .dataview.table-view-table td:nth-child(2) {
  width: 120px !important;
  max-width: 120px !important;
  text-align: center !important;
}
.dataview.table-view-table th:nth-child(3), .dataview.table-view-table td:nth-child(3) {
  width: 64px !important;
  max-width: 64px !important;
  text-align: center !important;
}
.dataview.table-view-table th:nth-child(4), .dataview.table-view-table td:nth-child(4) {
  width: 64px !important;
  max-width: 64px !important;
  text-align: center !important;
}

/* 第一列（中文名）：承担换行压力，最多两行，超过截断 */
.dataview.table-view-table th:nth-child(1), .dataview.table-view-table td:nth-child(1) {
  min-width: 220px !important;
  max-width: calc(100% - 248px) !important; /* 248 = 120 + 64 + 64 */
  white-space: normal !important;
  word-break: break-word !important;
  overflow: hidden !important;
  display: -webkit-box !important;
  -webkit-line-clamp: 2 !important;      /* 最多两行 */
  -webkit-box-orient: vertical !important;
}

/* 季度统计行加粗，表头加粗 */
.dataview.table-view-table td.season-summary { font-weight: 700 !important; }
.dataview.table-view-table thead th { font-weight: 600 !important; }
</style>`);

// --- 工具函数：提取表格字段、季度、subject id ---
function extractField(content, field) {
  if (!content) return null;
  const esc = field.replace(/[.*+?^${}()|[\\\]\\]/g, "\\$&");
  const re = new RegExp("^\\|\\s*" + esc + "\\s*\\|\\s*([^|\\n]+?)\\s*\\|", "m");
  const m = content.match(re);
  return m ? m[1].trim() : null;
}

// 优先从路径匹配 /YYYY/MM月(new?)番/ 或 /YYYY/MM月/
// 若路径无季度信息，再尝试正文的“开播日期”字段（例：2020年4月1日）
function seasonFromPathOrContent(path, content) {
  let m = path.match(/\/(\d{4})\/(\d{1,2})月(?:新番)?(?:\/|$)/i);
  if (m) {
    const y = m[1], mm = String(m[2]).padStart(2, "0");
    return { label: `${y}年${mm}月`, key: parseInt(y + mm) };
  }
  m = path.match(/\/(\d{4})\/(\d{1,2})月(?:\/|$)/);
  if (m) {
    const y = m[1], mm = String(m[2]).padStart(2, "0");
    return { label: `${y}年${mm}月`, key: parseInt(y + mm) };
  }
  // 从正文开播日期提取年和月
  const playDate = extractField(content, "开播日期") || extractField(content, "放送开始") || extractField(content, "上映年度") || extractField(content, "放送日期");
  if (playDate) {
    const ym = playDate.match(/(\d{4})\s*年\s*(\d{1,2})\s*月/);
    if (ym) {
      const y = ym[1], mm = String(ym[2]).padStart(2, "0");
      return { label: `${y}年${mm}月`, key: parseInt(y + mm) };
    }
    const yOnly = playDate.match(/(\d{4})/);
    if (yOnly) {
      const y = yOnly[1];
      return { label: `${y}年`, key: parseInt(y + "00") };
    }
  }
  return { label: "未知季度", key: 0 };
}

function extractSubjectId(content) {
  if (!content) return null;
  const m1 = content.match(/bgm\.tv\/subject\/(\d+)/);
  if (m1) return m1[1];
  const m2 = content.match(/netaba\.re\/subject\/(\d+)/);
  if (m2) return m2[1];
  return null;
}

// --- 收集并解析笔记数据 ---
const pages = dv.pages().where(p => p.file && p.file.path && p.file.path.startsWith(ROOT_FOLDER)).array();
const items = [];
for (const p of pages) {
  try {
    const path = p.file.path;
    const file = app.vault.getAbstractFileByPath(path);
    const content = file ? await app.vault.read(file) : "";
    const cn = extractField(content, "中文名") || p.file.name || p.file.path.split("/").pop().replace(/\.md$/, "");
    const state = extractField(content, "观看状态") || "未知";
    let personalStr = (extractField(content, "个人评分") || "").replace(/分\s*$/,"").trim() || "";
    let bgmStr = (extractField(content, "BGM 评分") || "").replace(/分\s*$/,"").trim() || "";
    const personalNum = personalStr === "" ? null : Number(personalStr);
    const bgmNum = bgmStr === "" ? null : Number(bgmStr);
    const season = seasonFromPathOrContent(path, content);
    const subjectId = extractSubjectId(content);
    items.push({ path, cn, state, personalStr, personalNum, bgmStr, bgmNum, seasonLabel: season.label, seasonKey: season.key, subjectId });
  } catch (e) {
    console.error("解析文件出错：", p.file.path, e);
  }
}

// --- 排序：季度 desc -> 个人评分 desc -> BGM desc -> 中文名 asc ---
function compareItems(a, b) {
  if ((a.seasonKey || 0) !== (b.seasonKey || 0)) return (b.seasonKey || 0) - (a.seasonKey || 0);
  const pa = (a.personalNum != null ? a.personalNum : -Infinity);
  const pb = (b.personalNum != null ? b.personalNum : -Infinity);
  if (pb - pa !== 0) return pb - pa;
  const ba = (a.bgmNum != null ? a.bgmNum : -Infinity);
  const bb = (b.bgmNum != null ? b.bgmNum : -Infinity);
  if (bb - ba !== 0) return bb - ba;
  return String(a.cn).localeCompare(String(b.cn), "zh-CN");
}

// --- 输出（每个状态一张表，表内插入季度统计行） ---
const statusOrder = ["已看", "在看", "想看", "抛弃"];
for (const status of statusOrder) {
  dv.header(2, status);
  const group = items.filter(it => it.state === status);
  if (!group || group.length === 0) { dv.paragraph("_无条目_"); continue; }
  group.sort(compareItems);

  // 按季度分组
  const bySeason = new Map();
  for (const it of group) {
    const key = it.seasonKey || 0;
    if (!bySeason.has(key)) bySeason.set(key, []);
    bySeason.get(key).push(it);
  }
  const seasonKeys = Array.from(bySeason.keys()).sort((a, b) => b - a);

  // 构建表行（季度统计行 + 项目行）
  const rows = [];
  for (const sk of seasonKeys) {
    const list = bySeason.get(sk);
    const seasonLabel = list[0].seasonLabel || "未知季度";
    rows.push([ `**${seasonLabel} — 共 ${list.length} 部**`, "", "", ""]); // 季度统计行
    for (const it of list) {
      rows.push([
        dv.fileLink(it.path, false),
        it.seasonLabel,
        (it.personalNum != null ? it.personalNum.toFixed(1) : ""),
        (it.bgmNum != null ? it.bgmNum.toFixed(1) : (it.bgmStr || ""))
      ]);
    }
  }

  // 表头把评分列以 <br> 变为两行显示（不会在表体被拆字）
  dv.table(["中文名", "   开播季度        ", "个人<br>评分", "BGM<br>评分"], rows);
}

```
